<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="info" docName="draft-ietf-rmcat-gcc-01"
     ipr="trust200902">
  <front>
    <title abbrev="Congestion Control for RTCWEB">A Google Congestion Control
    Algorithm for Real-Time Communication</title>

    <author fullname="Stefan Holmer" initials="S." surname="Holmer">
      <organization>Google</organization>

      <address>
        <postal>
          <street>Kungsbron 2</street>

          <code>11122</code>

          <city>Stockholm</city>

          <country>Sweden</country>
        </postal>

        <email>holmer@google.com</email>
      </address>
    </author>

    <author fullname="Henrik Lundin" initials="H." surname="Lundin">
      <organization>Google</organization>

      <address>
        <postal>
          <street>Kungsbron 2</street>

          <code>11122</code>

          <city>Stockholm</city>

          <country>Sweden</country>
        </postal>

        <email>hlundin@google.com</email>
      </address>
    </author>

    <author fullname="Gaetano Carlucci" initials="G." surname="Carlucci">
         <organization>Politecnico di Bari</organization>

          <address>
            <postal>
              <street>Via Orabona, 4</street>

              <code>70125</code>

              <city>Bari</city>

              <country>Italy</country>
            </postal>

            <email>gaetano.carlucci@poliba.it</email>
           </address>
    </author>
    <author fullname="Luca De Cicco" initials="L." surname="De Cicco">
         <organization>Politecnico di Bari</organization>

          <address>
            <postal>
              <street>Via Orabona, 4</street>

              <code>70125</code>

              <city>Bari</city>

              <country>Italy</country>
            </postal>

            <email>l.decicco@poliba.it</email>
           </address>
    </author>

    <author fullname="Saverio Mascolo" initials="S." surname="Mascolo">
         <organization>Politecnico di Bari</organization>

          <address>
            <postal>
              <street>Via Orabona, 4</street>

              <code>70125</code>

              <city>Bari</city>

              <country>Italy</country>
            </postal>

            <email>mascolo@poliba.it</email>
           </address>
    </author>

    <date day="19" month="October" year="2015" />

    <abstract>
      <t>This document describes two methods of congestion control when using
      real-time communications on the World Wide Web (RTCWEB); one
      delay-based and one loss-based.</t>

      <t>It is published as an input document to the RMCAT working group on
      congestion control for media streams. The mailing list of that working
      group is rmcat@ietf.org.</t>
    </abstract>

    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>Congestion control is a requirement for all applications sharing
      the Internet resources <xref target="RFC2914"></xref>.</t>

      <t>Congestion control for real-time media is challenging
      for a number of reasons:</t>

      <t><list style="symbols">
          <t>The media is usually encoded in forms that cannot be quickly
          changed to accommodate varying bandwidth, and bandwidth requirements
          can often be changed only in discrete, rather large steps</t>

          <t>The participants may have certain specific wishes on how to
          respond - which may not be reducing the bandwidth required by the
          flow on which congestion is discovered</t>

          <t>The encodings are usually sensitive to packet loss, while the
          real-time requirement precludes the repair of packet loss by
          retransmission</t>
        </list>This memo describes two congestion control algorithms that
      together are able to provide good performance and reasonable
      bandwidth sharing with other video flows using the same congestion control
      and with TCP flows that share the same links.</t>

      <t>The signaling used consists of experimental RTP header extensions
      and RTCP messages <xref target="RFC3550">RFC 3550</xref> as defined in
      <xref target="abs-send-time"></xref>,
      <xref target="I-D.alvestrand-rmcat-remb"></xref> and
      <xref target="I-D.holmer-rmcat-transport-wide-cc-extensions"/>.</t>

      <t></t>

      <section title="Mathematical notation conventions">
        <t>The mathematics of this document have been transcribed from a more
        formula-friendly format.</t>

        <t>The following notational conventions are used:</t>

        <t><list style="hanging">
            <t hangText="X_hat">An estimate of the true value of variable X -
            conventionally marked by a circumflex accent on top of the
            variable name.</t>

            <t hangText="X(i)">The "i"th value of vector X - conventionally marked by
            a subscript i.</t>

            <t hangText="E{X}">The expected value of the stochastic variable
            X</t>
          </list></t>
      </section>
    </section>

    <section title="System model">
      <t>The following elements are in the system:</t>

      <t><list style="symbols">
          <t>RTP packet - an RTP packet containing media data.</t>

          <t>Packet group - a set of RTP packets transmitted from the sender uniquely
          identified by the group departure and group arrival time (absolute send time)
          <xref target="abs-send-time"></xref>. These could be video packets, audio packets,
          or a mix of audio and video packets.</t>

          <t>Incoming media stream - a stream of frames consisting of RTP
          packets.</t>

          <t>RTP sender - sends the RTP stream over the network to the RTP
          receiver. It generates the RTP timestamp and the abs-send-time header
          extension</t>

          <t>RTP receiver - receives the RTP stream, marks the time of
          arrival.</t>

          <t>RTCP sender at RTP receiver - sends receiver reports,
          REMB messages and transport-wide RTCP feedback messages.</t>

          <t>RTCP receiver at RTP sender - receives receiver reports and
          REMB messages and transport-wide RTCP feedback messages,
          reports these to the sender side controller.</t>

          <t>RTCP receiver at RTP receiver, receives sender reports from
          the sender.</t>

          <t>Loss-based controller - takes loss rate measurement, round trip time measurement
          and REMB messages, and computes a target sending bitrate.</t>

          <t>Delay-based controller - takes the packet arrival info, either at the
          RTP receiver, or from the feedback received by the RTP sender, and
          computes a maximum bitrate which it passes to the loss-based
          controller.</t>
        </list>Together, loss-based controller and delay-based controller
      implement the congestion control algorithm.</t>

      <t></t>
    </section>

    <section anchor="extensions" title="Feedback and extensions">
      <t>There are two ways to implement the proposed algorithm. One where
      both the controllers are running at the send-side, and one where the
      delay-based controller runs on the receive-side and the loss-based
      controller runs on the send-side.
      </t>

      <t>The first version can be realized by using a per-packet feedback
      protocol as described in
      <xref target="I-D.holmer-rmcat-transport-wide-cc-extensions"/>. Here,
      the RTP receiver will record the arrival time and the transport-wide
      sequence number of each received packet, which will be sent back to
      the sender periodically using the transport-wide feedback message. The
      RECOMMENDED feedback interval is once per received video frame or at least
      once every 30 ms if audio-only or multi-stream. If the feedback overhead
      needs to be limited this interval can be increased to 100 ms.
      </t>

      <t>The sender will map the received {sequence number, arrival time} pairs
      to the send-time of each packet covered by the feedback report, and feed
      those timestamps to the delay-based controller. It will also compute a loss
      ratio based on the sequence numbers in the feedback message.</t>

      <t>The second version can be realized by having a delay-based controller
      at the receive-side, monitoring and processing the arrival time and size
      of incoming packets. The sender SHOULD use the abs-send-time RTP header
      extension <xref target="abs-send-time"></xref> to enable the receiver to
      compute the inter-group delay variation. The output from the delay-based
      controller will be a bitrate, which will be sent back to the sender using
      the REMB feedback message
      <xref target="I-D.alvestrand-rmcat-remb"></xref>.
      The packet loss ratio is sent back via RTCP receiver reports. At the
      sender the bitrate in the REMB message and the fraction of packets lost
      are fed into the loss-based controller, which outputs a final target
      bitrate. It is RECOMMENDED to send the REMB message as soon as congestion
      is detected, and otherwise at least once every second.</t>
    </section>

    <section anchor="delaybased" title="Delay-based control">
      <t>The delay-based control algorithm can be further decomposed into three parts:
      an arrival-time filter, an over-use detector, and a rate controller.</t>

      <t></t>

      <section title="Arrival-time model">
        <t>This section describes an adaptive filter that continuously updates
        estimates of network parameters based on the timing of the received
        packets.</t>

        <t>We define the inter-arrival time, t(i) - t(i-1), as the difference in
        arrival time of two packets or two groups of packets. Correspondingly,
        the inter-departure time, T(i) - T(i-1), is defined as the difference in
        departure-time of two packets or two groups of packets. Finally, the
        inter-group delay variation, d(i), is defined as the difference between
        the inter-arrival time and the inter-departure time. Or interpreted
        differently, as the difference between the delay of group i and group
        i-1.</t>
        <figure>
          <artwork><![CDATA[
  d(i) = t(i) - t(i-1) - (T(i) - T(i-1))
]]></artwork>
        </figure>

        <t>At the receiving side we are observing groups of incoming packets,
        where a group of packets is defined as follows:</t>

        <t><list style="symbols">
          <t>A sequence of packets which are sent within a burst_time interval
          constitute a group. RECOMMENDED value for burst_time is 5 ms.</t>

          <t>In addition, any packet which has an inter-arrival time less
          than burst_time and an inter-group delay variation d(i) less than 0 is
          also considered being part of the current group of packets. The
          reasoning behind including these packets in the group is to better
          handle delay transients, caused by packets being queued up for reasons
          unrelated to congestion. As an example this has been observed to
          happen on many Wi-Fi and wireless networks.</t>
        </list></t>

        <t>An inter-departure time is computed between consecutive groups as
        T(i) - T(i-1), where T(i) is the departure timestamp of the last packet
        in the current packet group being processed. Any packets received
        out of order are ignored by the arrival-time model.</t>

        <t>Each group is assigned a receive time t(i), which corresponds to
        the time at which the last packet of the group was received. A group
        is delayed relative to its predecessor if
        t(i) - t(i-1) &gt; T(i) - T(i-1), i.e., if the inter-arrival time is
        larger than the inter-departure time.</t>

       <t>We can model the inter-group delay variation as:</t>
        <figure>
          <artwork><![CDATA[
  d(i) = w(i)
]]></artwork>
        </figure>

        <t>Here, w(i) is a sample from a stochastic process W, which is a
        function of the link capacity, the current cross traffic, and the
        current sent bitrate. We model W as a white Gaussian process.
        If we are over-using the channel we expect the mean of w(i) to increase,
        and if a queue on the network path is
        being emptied, the mean of w(i) will decrease; otherwise the mean of
        w(i) will be zero.</t>

        <t>Breaking out the mean, m(i), from w(i) to make the process zero mean,
        we get</t>

        <figure>
          <preamble>Equation 1</preamble>
          <artwork><![CDATA[
  d(i) = m(i) + v(i)
]]></artwork>
        </figure>

        <t>The noise term v(i) represents network jitter and other delay 
          effects not captured by the model.</t>

      </section>

      <section title="Arrival-time filter">
        <t>The parameter d(i) is readily available for each group
        of packets, i &gt; 1. We want to estimate m(i) and use
        this estimate to detect whether or not the bottleneck link is
        over-used. The parameter can be estimated by any
        adaptive filter &ndash; we are using the Kalman filter.</t>

        <t>Let m(i) be the estimate at time i</t>

        <t> We model the state evolution from
        time i to time i+1 as</t>

        <t></t>

        <figure>
          <artwork><![CDATA[
  m(i+1) = m(i) + u(i)
]]></artwork>
        </figure>

        <t>where u(i) is the state noise that we model as a stationary
        process with Gaussian statistic with zero mean and variance</t>

        <t></t>

        <figure>
          <artwork><![CDATA[
  q(i) = E{u(i)^2}
]]></artwork>
        </figure>

        <t> q(i) is RECOMMENDED equal to 10^-3</t>

        <t>Given equation 1 we get</t>

        <figure>
          <artwork><![CDATA[
    d(i) = m(i) + v(i)
]]></artwork>
        </figure>

        <t>where v(i) is zero mean white Gaussian measurement noise with
        variance var_v = E{v(i)^2}</t>

        <t>The Kalman filter recursively updates our estimate m_hat(i) as</t>

        <figure>
          <artwork><![CDATA[
  z(i) = d(i) - m_hat(i-1)

  m_hat(i) = m_hat(i-1) + z(i) * k(i)

                     e(i-1) + q(i)
  k(i) = ----------------------------------------
             var_v_hat(i) + (e(i-1) + q(i))

  e(i) = (1 - k(i)) * (e(i-1) + q(i))
]]></artwork>
        </figure>

        <t>The variance var_v(i) = E{v(i)^2} is estimated using an
        exponential averaging filter, modified for variable sampling rate</t>

        <figure>
          <artwork><![CDATA[
  var_v_hat(i) = max(alpha * var_v_hat(i-1) + (1-alpha) * z(i)^2, 1)

  alpha = (1-chi)^(30/(1000 * f_max))
]]></artwork>
        </figure>

        <t>where f_max = max {1/(T(j) - T(j-1))} for j in i-K+1,...,i is the
        highest rate at which the last K packet groups have been received
        and chi is a filter coefficient typically chosen as a
        number in the interval [0.1, 0.001]. Since our assumption that v(i)
        should be zero mean WGN is less accurate in some cases, we have
        introduced an additional outlier filter around the updates of
        var_v_hat. If z(i) &gt; 3*sqrt(var_v_hat) the filter is updated with
        3*sqrt(var_v_hat) rather than z(i). For instance v(i) will not be white
        in situations where packets are sent at a higher rate than the channel
        capacity, in which case they will be queued behind each other.</t>
      </section>

      <section title="Over-use detector">
        <t>The inter-group delay variation estimate m(i), obtained as the output of the arrival-time
        filter, is compared with a threshold del_var_th(i).
        An estimate above the threshold is considered as an indication of
        over-use. Such an indication is not enough for the detector to signal
        over-use to the rate control subsystem. A definitive over-use will be
        signaled only if over-use has been detected for at least overuse_time_th
        milliseconds.
        However, if m(i) &lt; m(i-1), over-use will not be
        signaled even if all the above conditions are met. Similarly, the
        opposite state, under-use, is detected when m(i) &lt; -del_var_th(i). If
        neither over-use nor under-use is detected, the detector will be in
        the normal state.</t>
        <t>The threshold del_var_th has a remarkable impact on the overall dynamics
        and performance of the algorithm.
        In particular, it has been shown that using a static threshold del_var_th,
        a flow controlled by the proposed algorithm can be starved by a
        concurrent TCP flow <xref target="Pv13"/>. This starvation can be
        avoided by increasing the threshold del_var_th to a sufficiently large
        value.</t>
        <t>The reason is that, by using a larger value of del_var_th, a larger
        queuing delay can be tolerated, whereas with a small del_var_th, the
        over-use detector quickly reacts to a small increase in the offset estimate m(i)
        by generating an over-use signal that reduces the delay-based estimate
        of the available bandwidth A_hat (see Section 4.4).
        Thus, it is necessary to dynamically tune the threshold del_var_th to get good
        performance in the most common scenarios, such as when competing with
        loss-based flows.</t>
        <t>For this reason, we propose to vary the threshold del_var_th(i) according
        to the following dynamic equation:</t>
        <figure>
          <artwork><![CDATA[
del_var_th(i) = 
         del_var_th(i-1) + (t(i)-t(i-1)) * K(i) * (|m(i)|-del_var_th(i-1))
]]></artwork>
        </figure>
        <t>with K(i)=K_d if |m(i)| &lt; del_var_th(i-1) or K(i)=K_u otherwise.
        The rationale is  to increase del_var_th(i) when m(i) is outside of the range
        [-del_var_th(i-1),del_var_th(i-1)], whereas, when the offset estimate m(i)
        falls back into the range, del_var_th is decreased. In this way when
        m(i) increases, for instance due to a TCP flow entering the same
        bottleneck, del_var_th(i) increases and avoids the uncontrolled generation of
        over-use signals which may lead to starvation of the flow controlled by
        the proposed algorithm <xref target="Pv13"/>. Moreover, del_var_th(i) SHOULD NOT
        be updated if this condition holds:</t>
        <figure>
          <artwork><![CDATA[
  |m(i)| - del_var_th(i) > 15
]]></artwork>
        </figure>

        <t>It is also RECOMMENDED to clamp del_var_th(i) to the range [6, 600],
        since a too small del_var_th(i) can cause the detector to become overly
        sensitive.</t>

        <t>On the other hand, when m(i) falls back into the range
        [-del_var_th(i-1),del_var_th(i-1)] the threshold del_var_th(i) is decreased so
        that a lower queuing delay can be achieved.</t>
        <t>It is RECOMMENDED to choose K_u &gt; K_d so that the rate at which
        del_var_th is increased is higher than the rate at which it is decreased.
        With this setting it is possible to increase the threshold in the case
        of a concurrent TCP flow and prevent starvation as well as enforcing
        intra-protocol fairness.
        RECOMMENDED values for del_var_th(0), overuse_time_th, K_u and K_d are respectively
        12.5 ms, 10 ms, 0.01 and 0.00018.</t>
      </section>

      <section title="Rate control">
        <t>The rate control is split in two parts, one controlling the bandwidth
        estimate based on delay, and one controlling the bandwidth estimate
        based on loss. Both are designed to increase the estimate of the
        available bandwidth A_hat as long as there is no detected congestion and
        to ensure that we will eventually match the available bandwidth of the
        channel and detect an over-use.</t>

        <t>As soon as over-use has been detected, the available bandwidth estimated
        by the delay-based controller is decreased. In this way we get a recursive
        and adaptive estimate of the available bandwidth.</t>

        <t>In this document we make the assumption that the rate control
        subsystem is executed periodically and that this period is
        constant.</t>

        <t>The rate control subsystem has 3 states: Increase, Decrease and
        Hold. "Increase" is the state when no congestion is detected;
        "Decrease" is the state where congestion is detected, and "Hold" is a
        state that waits until built-up queues have drained before going to
        "increase" state.</t>

        <t>The state transitions (with blank fields meaning "remain in state")
        are:</t>

        <t></t>

        <figure>
          <artwork><![CDATA[+----+--------+-----------+------------+--------+
|     \ State |   Hold    |  Increase  |Decrease|
|      \      |           |            |        |
| Signal\     |           |            |        |
+--------+----+-----------+------------+--------+
|  Over-use   | Decrease  |  Decrease  |        |
+-------------+-----------+------------+--------+
|  Normal     | Increase  |            |  Hold  |
+-------------+-----------+------------+--------+
|  Under-use  |           |   Hold     |  Hold  |
+-------------+-----------+------------+--------+
]]></artwork>
        </figure>

        <t>The subsystem starts in the increase state, where it will stay
        until over-use or under-use has been detected by the detector
        subsystem. On every update the delay-based estimate of the available
        bandwidth is increased, either multiplicatively or additively,
        depending on its current state.</t>

        <t>The system does a multiplicative
        increase if the current bandwidth estimate appears to be far from
        convergence, while it does an additive increase if it appears to
        be closer to convergence. We assume that we are close to convergence
        if the currently incoming bitrate, R_hat(i), is close to an average
        of the incoming bitrates at the time when we previously have been in
        the Decrease state. "Close" is defined as three standard deviations
        around this average. It is RECOMMENDED to measure this average and
        standard deviation with an exponential moving average with the
        smoothing factor 0.95, as it is expected that this average covers
        multiple occasions at which we are in the Decrease state.
        Whenever valid estimates of these statistics are not available, we
        assume that we have not yet come close to convergence and therefore
        remain in the multiplicative increase state.</t>

        <t>If R_hat(i) increases above three standard deviations of the
        average max bitrate, we assume that the current congestion level
        has changed, at which point we reset the average max bitrate and
        go back to the multiplicative increase state.</t>

        <t>R_hat(i) is the incoming bitrate measured by the delay-based
        controller over a T seconds
        window:</t>

        <figure>
          <artwork><![CDATA[
  R_hat(i) = 1/T * sum(L(j)) for j from 1 to N(i)]]></artwork>
        </figure>

        <t>N(i) is the number of packets received the past T seconds and L(j)
        is the payload size of packet j. A window between 0.5 and 1 second
        is RECOMMENDED.</t>

        <t>During multiplicative increase, the estimate is increased by
        at most 8% per second.</t>

        <figure>
          <artwork><![CDATA[
  eta = 1.08^min(time_since_last_update_ms / 1000, 1.0)
  A_hat(i) = eta * A_hat(i-1)]]></artwork>
        </figure>

        <t>During the additive increase the estimate is increased with at most
        half a packet per response_time interval. The response_time interval
        is estimated as the round-trip time plus 100 ms as an estimate of
        over-use estimator and detector reaction time.</t>

        <figure>
          <artwork><![CDATA[
  response_time_ms = 100 + rtt_ms
  alpha = 0.5 * min(time_since_last_update_ms / response_time_ms, 1.0)
  A_hat(i) = A_hat(i-1) + max(1000, alpha * expected_packet_size_bits)]]></artwork>
        </figure>

        <t>expected_packet_size_bits is used to get a slightly slower slope for
        the additive increase at lower bitrates. It can for instance be computed
        from the current bitrate by assuming a frame rate of 30 frames per
        second:</t>

        <figure>
          <artwork><![CDATA[
  bits_per_frame = A_hat(i-1) / 30
  packets_per_frame = ceil(bits_per_frame / (1200 * 8))
  avg_packet_size_bits = bits_per_frame / packets_per_frame
]]></artwork>
        </figure>

        <t>Since the system depends on over-using the channel to verify the
        current available bandwidth estimate, we must make sure that our
        estimate does not diverge from the rate at which the sender is actually
        sending. Thus, if the sender is unable to produce a bit stream with
        the bitrate the congestion controller is asking for, the available
        bandwidth estimate should stay within a given bound. Therefore we
        introduce a threshold</t>

        <figure>
          <artwork><![CDATA[
  A_hat(i) < 1.5 * R_hat(i)
]]></artwork>
        </figure>

        <t>When an over-use is detected the system transitions to the decrease
        state, where the delay-based available bandwidth estimate is
        decreased to a factor times the currently incoming bitrate.</t>

        <figure>
          <artwork><![CDATA[
  A_hat(i) = beta * R_hat(i)]]></artwork>
        </figure>

        <t>beta is typically chosen to be in the interval [0.8, 0.95], 0.85
        is the RECOMMENDED value.</t>

        <t>When the detector signals under-use to the rate control subsystem,
        we know that queues in the network path are being emptied, indicating
        that our available bandwidth estimate A_hat is lower than the actual
        available bandwidth. Upon that signal the rate control subsystem will
        enter the hold state, where the receive-side available bandwidth
        estimate will be held constant while waiting for the queues to
        stabilize at a lower level &ndash; a way of keeping the delay as low
        as possible. This decrease of delay is wanted, and expected,
        immediately after the estimate has been reduced due to over-use, but
        can also happen if the cross traffic over some links is reduced.</t>

        <t>It is RECOMMENDED that the routine to update A_hat(i) is run at least
        once every response_time interval.</t>
      </section>

    <section title="Parameters settings">

       <texttable anchor="VACS_US">
          <ttcol>Parameter</ttcol>

          <ttcol>Description</ttcol>

          <ttcol>RECOMMENDED Value</ttcol>

          <c>burst_time</c>
          <c>Time limit in milliseconds between packet bursts which identifies a group</c>
          <c>5 ms</c>

          <c>q</c>
          <c>State noise covariance matrix </c>
          <c>q = 10^-3</c>

          <c>e(0)</c>
          <c>Initial value of the  system error covariance</c>
          <c>e(0) = 0.1</c>

          <c>chi</c>
          <c>Coefficient used  for the measured noise variance</c>
          <c>[0.1, 0.001]</c>

          <c>del_var_th(0)</c>
          <c>Initial value for the adaptive threshold</c>
          <c>12.5 ms</c>

          <c>overuse_time_th</c>
          <c>Time required to trigger an overuse signal</c>
          <c>10 ms</c>

          <c>K_u</c>
          <c>Coefficient for the adaptive threshold</c>
          <c>0.01</c>

          <c>K_d</c>
          <c>Coefficient for the adaptive threshold</c>
          <c>0.00018</c>

          <c>T</c>
          <c>Time window for measuring the received bitrate</c>
          <c>[0.5, 1] s</c>

          <c>beta</c>
          <c>Decrease rate factor</c>
          <c>0.85</c>

          <postamble>Table 1: RECOMMENDED values for delay based controller</postamble>
        </texttable>
    </section>
    </section>

    <section anchor="lossbased" title="Loss-based control">
      <t>A second part of the congestion controller bases its decisions on the
      round-trip time, packet loss and available bandwidth estimates A_hat
      received from the delay-based controller. The available bandwidth
      estimates computed by the loss-based controller are denoted with As_hat.
      </t>

      <t>The available bandwidth estimates A_hat produced by the delay-based
      controller are only reliable when the size of the queues along the path
      sufficiently large. If the queues are very short, over-use will only be
      visible through packet losses, which are not used by the delay-based
      controller.</t>

      <t>The loss-based controller SHOULD run every time feedback from the
      receiver is received.</t>

      <t><list style="symbols">
          <t>If 2-10% of the packets have been lost since the previous report
          from the receiver, the sender available bandwidth estimate As_hat(i)
          will be kept unchanged.</t>

          <t>If more than 10% of the packets have been lost a new estimate is
          calculated as As_hat(i) = As_hat(i-1)(1-0.5p), where p is the loss
          ratio.</t>

          <t>As long as less than 2% of the packets have been lost As_hat(i)
          will be increased as As_hat(i) = 1.05(As_hat(i-1))</t>
        </list></t>

      <t>The loss-based estimate As_hat is compared with the delay-based
      	 estimate A_hat. The actual sending rate is set as the minimum
      	 between As_hat and A_hat.
      </t>

      <t>We motivate the packet loss thresholds by noting that if the
      transmission channel has a small amount of packet loss due to over-use,
      that amount will soon increase if the sender does not adjust his bitrate.
      Therefore we will soon enough reach above the 10% threshold and
      adjust As_hat(i). However, if the packet loss ratio does not increase, the
      losses are probably not related to self-inflicted congestion and
      therefore we should not react on them.</t>
    </section>

    <section title="Interoperability Considerations">
      <t>In case a sender implementing these algorithms talks to a receiver
      which do not implement any of the proposed RTCP messages and RTP header
      extensions, it is suggested that the sender monitors RTCP receiver reports
      and uses the fraction of lost packets and the round-trip time as input
      to the loss-based controller. The delay-based controller should be left
      disabled.</t>
    </section>

    <section title="Implementation Experience">
      <t>This algorithm has been implemented in the open-source WebRTC
      project, has been in use in Chrome since M23, and is being used by
      Google Hangouts.</t>

      <t>Deployment of the algorithm have revealed problems related to, e.g,
      congested or otherwise problematic WiFi networks, which have led to
      algorithm improvements. The algorithm has also been tested in a
      multi-party conference scenario with a conference server which
      terminates the congestion control between endpoints. This ensures that
      no assumptions are being made by the congestion control about maximum
      send and receive bitrates, etc., which typically is out of control
      for a conference server.</t>
    </section>

    <section title="Further Work">
      <t>This draft is offered as input to the congestion control
      discussion.</t>

      <t>Work that can be done on this basis includes:</t>

      <t><list style="symbols">
          <t>Considerations of integrated loss control: How loss and delay
          control can be better integrated, and the loss control improved.</t>

          <t>Considerations of locus of control: evaluate the performance of
          having all congestion control logic at the sender, compared to
          splitting logic between sender and receiver.</t>

          <t>Considerations of utilizing ECN as a signal for congestion
          estimation and link over-use detection.</t>
        </list></t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document makes no request of IANA.</t>

      <t>Note to RFC Editor: this section may be removed on publication as an
      RFC.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>An attacker with the ability to insert or remove messages on the
      connection would have the ability to disrupt rate control.
      This could make the algorithm to produce either a sending rate
      under-utilizing the bottleneck link capacity, or a too high sending rate
      causing network congestion.</t>

      <t>In this case, the control information is carried inside RTP, and can
      be protected against modification or message insertion using SRTP, just
      as for the media. Given that timestamps are carried in the RTP header,
      which is not encrypted, this is not protected against disclosure, but it
      seems hard to mount an attack based on timing information only.</t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>Thanks to Randell Jesup, Magnus Westerlund, Varun Singh, Tim Panton,
      Soo-Hyun Choo, Jim Gettys, Ingemar Johansson, Michael Welzl and others
      for providing valuable feedback on earlier versions of this draft.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include='reference.RFC.3448'?>

      <?rfc include='reference.RFC.3550'?>

      <?rfc include='reference.I-D.alvestrand-rmcat-remb'?>

      <?rfc include='reference.I-D.holmer-rmcat-transport-wide-cc-extensions'?>

      <reference anchor="abs-send-time" target="http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time">
        <front>
          <title>RTP Header Extension for Absolute Sender Time</title>
          <author/>
          <date/>
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include='reference.RFC.2914'?>

      <reference anchor='Pv13'>
        <front>
          <title abbrev='Pv13'>Understanding the Dynamic Behaviour of the Google Congestion Control</title>
          <author initials='L.' surname='De Cicco' fullname='Luca De Cicco'>
            <organization>Politecnico di Bari</organization>
            <address>
              <postal>
                <street>Via Orabona, 4</street>
                <street>70125 Bari</street>
                <street>Italy</street>
              </postal>
              <phone>+39 080 596 3851</phone>
              <email>l.decicco@poliba.it</email>
             </address>
          </author>
          <author initials='G.' surname='Carlucci' fullname='Gaetano Carlucci'>
            <organization>Politecnico di Bari</organization>
            <address>
              <postal>
                <street>Via Orabona, 4</street>
                <street>70125 Bari</street>
                <street>Italy</street>
              </postal>
              <phone>+39 080 596 3851</phone>
              <email>g.carlucci@poliba.it</email>
             </address>
          </author>
          <author initials='S.' surname='Mascolo' fullname='Saverio Mascolo'>
            <organization>Politecnico di Bari</organization>
            <address>
              <postal>
                <street>Via Orabona, 4</street>
                <street>70125 Bari</street>
                <street>Italy</street>
              </postal>
              <phone>+39 080 596 3621</phone>
              <email>mascolo@poliba.it</email>
             </address>
          </author>
          <date year='2013' month='December' />
          <area>General</area>
        </front>
        <seriesInfo name="Packet Video Workshop" value="" />
        <format type="PDF" target="http://c3lab.poliba.it/images/c/ce/Gcc-pv-2013.pdf"/>
      </reference>

    </references>

    <section title="Change log">
      <t></t>

      <section title="Version -00 to -01">
        <t><list style="symbols">
            <t>Added change log</t>

            <t>Added appendix outlining new extensions</t>

            <t>Added a section on when to send feedback to the end of section
            3.3 "Rate control", and defined min/max FB intervals.</t>

            <t>Added size of over-bandwidth estimate usage to "further work"
            section.</t>

            <t>Added startup considerations to "further work" section.</t>

            <t>Added sender-delay considerations to "further work"
            section.</t>

            <t>Filled in acknowledgments section from mailing list
            discussion.</t>
          </list></t>
      </section>

      <section title="Version -01 to -02">
        <t><list style="symbols">
            <t>Defined the term "frame", incorporating the transmission time
            offset into its definition, and removed references to "video
            frame".</t>

            <t>Referred to "m(i)" from the text to make the derivation
            clearer.</t>

            <t>Made it clearer that we modify our estimates of available
            bandwidth, and not the true available bandwidth.</t>

            <t>Removed the appendixes outlining new extensions, added pointers
            to REMB draft and RFC 5450.</t>
          </list></t>
      </section>

      <section title="Version -02 to -03">
        <t><list style="symbols">
            <t>Added a section on how to process multiple streams in a single
            estimator using RTP timestamps to NTP time conversion.</t>

            <t>Stated in introduction that the draft is aimed at the RMCAT
            working group.</t>
          </list></t>
      </section>

      <section title="rtcweb-03 to rmcat-00">
        <t>Renamed draft to link the draft name to the RMCAT WG.</t>
      </section>

      <section title="rmcat -00 to -01">
        <t>Spellcheck. Otherwise no changes, this is a "keepalive"
        release.</t>

        <t></t>
      </section>

      <section title="rmcat -01 to -02">
        <t><list style="symbols">
            <t>Added Luca De Cicco and Saverio Mascolo as authors.</t>

            <t>Extended the "Over-use detector" section with new technical
             details on how to dynamically tune the offset del_var_th for improved
             fairness properties.</t>

            <t>Added reference to a paper analyzing the behavior of the proposed
             algorithm.</t>
          </list></t>
      </section>

      <section title="rmcat -02 to -03">
        <t><list style="symbols">
            <t>Swapped receiver-side/sender-side controller with
            delay-based/loss-based controller as there is no longer a requirement
            to run the delay-based controller on the receiver-side.</t>

            <t>Removed the discussion about multiple streams and transmission time
            offsets.</t>

            <t>Introduced a new section about "Feedback and extensions".</t>

            <t>Improvements to the threshold adaptation in the "Over-use detector"
            section.</t>

            <t>Swapped the previous MIMD rate control algorithm for a new AIMD
            rate control algorithm.</t>
          </list></t>
      </section>

      <section title="ietf-rmcat -00 to ietf-rmcat -01">
        <t><list style="symbols">
          <t>Arrival-time filter converted from a two dimensional Kalman filter
          to a scalar Kalman filter.</t>

          <t>The use of the TFRC equation was removed from the loss-based
          controller, as it turned out to have little to no effect in
          practice.</t>
        </list></t>
      </section>
    </section>
  </back>
</rfc>

