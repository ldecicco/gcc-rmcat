<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="info" docName="draft-alvestrand-rmcat-congestion-03"
     ipr="trust200902">
  <front>
    <title abbrev="Congestion Control for RTCWEB">A Google Congestion Control
    Algorithm for Real-Time Communication</title>

    <author fullname="Henrik Lundin" initials="H." surname="Lundin">
      <organization>Google</organization>

      <address>
        <postal>
          <street>Kungsbron 2</street>

          <code>11122</code>

          <city>Stockholm</city>

          <country>Sweden</country>
        </postal>
      </address>
    </author>

    <author fullname="Stefan Holmer" initials="S." surname="Holmer">
      <organization>Google</organization>

      <address>
        <postal>
          <street>Kungsbron 2</street>

          <code>11122</code>

          <city>Stockholm</city>

          <country>Sweden</country>
        </postal>

        <email>holmer@google.com</email>
      </address>
    </author>
    <author fullname="Gaetano Carlucci" initials="G." surname="Carlucci">
         <organization>Politecnico di Bari</organization> 

          <address>
            <postal>
              <street>Via Orabona, 4</street>

              <code>70125</code>

              <city>Bari</city>

              <country>Italy</country>
            </postal>

            <email>gaetano.carlucci@poliba.it</email>
           </address> 
    </author>
    <author fullname="Luca De Cicco" initials="L." surname="De Cicco">
         <organization>Politecnico di Bari</organization> 

          <address>
            <postal>
              <street>Via Orabona, 4</street>

              <code>70125</code>

              <city>Bari</city>

              <country>Italy</country>
            </postal>

            <email>l.decicco@poliba.it</email>
           </address> 
    </author>

    <author fullname="Saverio Mascolo" initials="S." surname="Mascolo">
         <organization>Politecnico di Bari</organization> 

          <address>
            <postal>
              <street>Via Orabona, 4</street>

              <code>70125</code>

              <city>Bari</city>

              <country>Italy</country>
            </postal>

            <email>mascolo@poliba.it</email>
           </address> 
    </author>

    <author fullname="Harald Alvestrand" initials="H. T." role="editor"
            surname="Alvestrand">
      <organization>Google</organization>

      <address>
        <postal>
          <street>Kungsbron 2</street>

          <code>11122</code>

          <city>Stockholm</city>

          <country>Sweden</country>
        </postal>

        <email>harald@alvestrand.no</email>
      </address>
    </author>

    <date day="19" month="August" year="2013" />

    <abstract>
      <t>This document describes two methods of congestion control when using
      real-time communications on the World Wide Web (RTCWEB); one
      sender-based and one receiver-based.</t>

      <t>It is published as an input document to the RMCAT working group on
      congestion control for media streams. The mailing list of that WG is
      rmcat@ietf.org.</t>
    </abstract>

    <note title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119">RFC 2119</xref>.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t>Congestion control is a requirement for all applications sharing
      the Internet resources <xref target="RFC2914"></xref>.</t>

      <t>Congestion control for real-time media is challenging
      for a number of reasons:</t>

      <t><list style="symbols">
          <t>The media is usually encoded in forms that cannot be quickly
          changed to accommodate varying bandwidth, and bandwidth requirements
          can often be changed only in discrete, rather large steps</t>

          <t>The participants may have certain specific wishes on how to
          respond - which may not be reducing the bandwidth required by the
          flow on which congestion is discovered</t>

          <t>The encodings are usually sensitive to packet loss, while the
          real-time requirement precludes the repair of packet loss by
          retransmission</t>
        </list>This memo describes two congestion control algorithms that
      together are able to provide good performance and reasonable 
      bandwidth sharing with other video flows using the same congestion control
      and with TCP flows that share the same links.</t>

      <t>The signaling used consists of experimental RTP header extensions
      and RTCP messages as defined in <xref target="abs-send-time"></xref>, <xref
      target="I-D.alvestrand-rmcat-remb"></xref> and <xref target="I-D.holmer-rmcat-transport-wide-cc-extensions"/>.</t>

      <t></t>

      <section title="Mathemathical notation conventions">
        <t>The mathematics of this document have been transcribed from a more
        formula-friendly format.</t>

        <t>The following notational conventions are used:</t>

        <t><list style="hanging">
            <t hangText="X_bar">The variable X, where X is a vector -
            conventionally marked by a bar on top of the variable name.</t>

            <t hangText="X_hat">An estimate of the true value of variable X -
            conventionally marked by a circumflex accent on top of the
            variable name.</t>

            <t hangText="X(i)">The "i"th value of vector X - conventionally marked by
            a subscript i.</t>

            <t hangText="[x y z]">A row vector consisting of elements x, y and
            z.</t>

            <t hangText="X_bar^T">The transpose of vector X_bar.</t>

            <t hangText="E{X}">The expected value of the stochastic variable
            X</t>
          </list></t>
      </section>
    </section>

    <section title="System model">
      <t>The following elements are in the system:</t>

      <t><list style="symbols">
          <t>RTP packet - an RTP packet containing media data.</t>

          <t>Packet group - a set of RTP packets transmitted from the sender uniquely
          identified by the group departure and group arrival time (absolute send time)
          <xref target="abs-send-time"></xref>. These could be video packets, audio packets,
          or a mix of audio and video packets.</t>

          <t>Incoming media stream - a stream of frames consisting of RTP
          packets.</t>

          <t>RTP sender - sends the RTP stream over the network to the RTP
          receiver. It generates the RTP timestamp.</t>

          <t>RTP receiver - receives the RTP stream, marks the time of
          arrival.</t>

          <t>RTCP sender at RTP receiver - sends receiver reports,
          REMB messages and transport-wide RTCP feedback messages.</t>

          <t>RTCP receiver at RTP sender - receives receiver reports and
          REMB messages and transport-wide RTCP feedback messages,
          reports these to sender side controller.</t>

          <t>RTCP receiver at RTP receiver.</t>

          <t>Loss-based controller - takes loss rate info, round trip time info,
          and REMB messages and computes a sending bitrate.</t>

          <t>Delay-based controller - takes the packet arrival info, either at the
          RTP receiver, or from the feedback received by the RTP sender, and
          computes a maximum bitrate which it passes to the loss-based
          controller.</t>
        </list>Together, loss-based controller and delay-based controller
      implement the congestion control algorithm.</t>

      <t></t>
    </section>

    <section anchor="extensions" title="Feedback and extensions">
      <t>There are two ways to implement the proposed algorithm. One where
      both the controllers are running at the send-side, and one where the
      delay-based controller runs on the receive-side and the loss-based
      controller runs on the send-side.
      </t>

      <t>The first version can be realized by using a per-packet feedback
      protocol as described in
      <xref target="I-D.holmer-rmcat-transport-wide-cc-extensions"/>. Here,
      the RTP receiver will record the arrival time and the transport-wide
      sequence number of each received packet, which will be sent back to
      the sender periodically using the transport-wide feedback message. The
      RECOMMENDED feedback interval is once per received video frame, but if the
      feedback overhead needs to be limited this interval can be increased to
      once every 100 ms.</t>

      <t>The sender will map the received {sequence number, arrival time} pairs
      to the send-time of each packet covered by the feedback report, and feed
      those timestamps to the delay-based controller. It will also compute a loss
      ratio based on the sequence numbers in the feedback message.</t>

      <t>The second version can be realized by having a delay-based controller
      at the receive-side, monitoring and processing the arrival time and size
      of incoming packets. The sender SHOULD use the abs-send-time RTP header
      extension <xref target="abs-send-time"></xref> to enable the receiver to
      compute the inter-group delay variation. The output from the delay-based
      controller will be a bitrate, which will be sent back to the sender using
      the REMB feedback message
      <xref target="I-D.alvestrand-rmcat-remb"></xref>.
      The packet loss ratio is sent back via RTCP receiver reports. At the
      sender the bitrate in the REMB message and the fraction of packets lost
      are fed into the loss-based controller, which outputs a final target
      bitrate. It is RECOMMENDED to send the REMB message as soon as congestion
      is detected if the delay-based controller runs on the receiver, and
      otherwise at least once every second.</t>
    </section>

    <section anchor="delaybased" title="Delay-based control">
      <t>The delay-based control algorithm can be further decomposed into three parts:
      an arrival-time filter, an over-use detector, and a rate controller.</t>

      <t></t>

      <section title="Arrival-time model">
        <t>This section describes an adaptive filter that continuously updates
        estimates of network parameters based on the timing of the received
        packets.</t>

        <t>We define the inter-arrival time, t(i)-t(i-1), as the difference in
        arrival time of two packets or two groups of packets. Correspondingly,
        the inter-departure time, T(i)-T(i-1), is defined as the difference in 
        departure-time of two packets or two groups of packets. Finally, the inter-group
        delay variation, d(i), is defined as the difference between the
        inter-arrival time and the inter-departure time. Or interpreted differently,
        as the difference between the delay of group i and group i-1.</t>
        <figure>
          <artwork><![CDATA[ 
  d(i) = t(i)-t(i-1)-(T(i)-T(i-1))

]]></artwork>
        </figure>

        <t>At the receiving side we are observing groups of incoming packets,
        where a group of packets is defined as follows:</t>

        <t><list style="symbols">
          <t>A sequence of packets which have inter-departure times which are less
          than or equal to burst_time constitute a group. RECOMMENDED value for burst_time
          is 5 ms.</t>

          <t>In addition, any packet which has an inter-arrival time less
          than burst_time and an inter-group delay variation d(i) less than 0 is also
          considered being part of the current group of packets. The reasoning
          behind including these packets in the group is to better handle
          delay transients, caused by packets being queued up for reasons
          unrelated to congestion. As an example this can be seen to happen
          on many Wi-Fi and wireless networks.</t>
        </list></t>

        <t>An inter-departure time is computed between consecutive groups as
        T(i) - T(i-1), where T(i) is the departure timestamp of the last packet
        in the current packet group being processed. Any packets received
        out of order are ignored by the arrival-time model.</t>

        <t>Each group is assigned a receive time t(i), which corresponds to
        the time at which the last packet of the group was received. A group
        is delayed relative to its predecessor if
        t(i)-t(i-1)&gt;T(i)-T(i-1), i.e., if the inter-arrival time is
        larger than the inter-departure time.</t>

        <t>Since the time ts to send a group of packets of size L over a path
        with a capacity of C is roughly</t>

        <figure>
          <artwork><![CDATA[
  ts = L/C

]]></artwork>
        </figure>

        <t>we can model the inter-group delay variation as:</t>

        <figure>
          <artwork><![CDATA[ 
           L(i)-L(i-1)
  d(i) = -------------- + w(i) = dL(i)/C + w(i)
               C(i)

]]></artwork>
        </figure>

        <t>Here, w(i) is a sample from a stochastic process W, which is a
        function of the capacity C(i), the current cross traffic X(i), and the
        current sent bit rate R(i). We model W as a white Gaussian process. If
        we are over-using the channel we expect w(i) to increase, and if a
        queue on the network path is being emptied, w(i) will decrease;
        otherwise the mean of w(i) will be zero.</t>

        <t>Breaking out the mean m(i) from w(i) to make the process zero mean,
        we get</t>

        <figure>
          <preamble>Equation 5</preamble>

          <artwork><![CDATA[
  d(i) = dL(i)/C(i) + m(i) + v(i)

]]></artwork>
        </figure>

        <t>This is our fundamental model, where we take into account that a
        large group of packets need more time to traverse the link than a small
        group, thus arriving with higher relative delay. The noise term
        represents network jitter and other delay effects not captured by the
        model.</t>

      </section>

      <section title="Arrival-time filter">
        <t>The parameters d(i) and dL(i) are readily available for each group
        of packets i &gt; 1, and we want to estimate C(i) and m(i) and use those
        estimates to detect whether or not the bottleneck link is 
        over-used. These parameters can be estimated by any
        adaptive filter &ndash; we are using the Kalman filter.</t>

        <t>Let</t>

        <figure>
          <artwork><![CDATA[
  theta_bar(i) = [1/C(i)  m(i)]^T
]]></artwork>
        </figure>

        <t>and call it the state at time i. We model the state evolution from
        time i to time i+1 as</t>

        <t></t>

        <figure>
          <artwork><![CDATA[
  theta_bar(i+1) = theta_bar(i) + u_bar(i)
]]></artwork>
        </figure>

        <t>where u_bar(i) is the state noise that we model as a stationary 
          process with Gaussian statistic with a zero mean and a
        covariance</t>

        <t></t>

        <figure>
          <preamble>Equation 7</preamble>

          <artwork><![CDATA[
  Q(i) = E{u_bar(i) u_bar(i)^T}

]]></artwork>
        </figure>

        <t> Q(i) is RECOMMENDED as a diagonal matrix with main diagonal
        elements as:</t>

        <figure>
          <artwork><![CDATA[
  diag(Q(i)) = [10^-13 10^-3]^T
]]></artwork>
        </figure>



        <t>Given equation 5 we get</t>

        <figure>
          <preamble>Equation 8</preamble>

          <artwork><![CDATA[
  d(i) = h_bar(i)^T theta_bar(i) + v(i)

  h_bar(i) = [dL(i)  1]^T

]]></artwork>
        </figure>

        <t>where v(i) is zero mean white Gaussian measurement noise with
        variance var_v = sigma(v,i)^2</t>

        <t>The Kalman filter recursively updates our estimate</t>

        <figure>
          <artwork><![CDATA[
  theta_hat(i) = [1/C_hat(i) m_hat(i)]^T]]></artwork>
        </figure>

        <t>as</t>

        <figure>
          <artwork><![CDATA[
  z(i) = d(i) - h_bar(i)^T * theta_hat(i-1)

  theta_hat(i) = theta_hat(i-1) + z(i) * k_bar(i)

                    ( E(i-1) + Q(i) ) * h_bar(i)
  k_bar(i) = ---------------------------------------------------
             var_v_hat + h_bar(i)^T * (E(i-1) + Q(i)) * h_bar(i)

  E(i) = (I - K_bar(i) * h_bar(i)^T) * ( E(i-1) + Q(i) )
]]></artwork>
        </figure>

        <t>I is the 2-by-2 identity matrix.</t>

        <t>The variance var_v = sigma(v,i)^2 is estimated using an exponential
        averaging filter, modified for variable sampling rate</t>

        <figure>
          <artwork><![CDATA[
  var_v_hat = beta*sigma(v,i-1)^2 + (1-beta)*z(i)^2

  beta = (1-alpha)^(30/(1000 * f_max))

]]></artwork>
        </figure>

        <t>where f_max = max {1/(T(j) - T(j-1))} for j in i-K+1,...,i is the
        highest rate at which frames have been captured by the camera the last
        K frames and alpha is a filter coefficient typically chosen as a
        number in the interval [0.1, 0.001]. Since our assumption that v(i)
        should be zero mean WGN is less accurate in some cases, we have
        introduced an additional outlier filter around the updates of
        var_v_hat. If z(i) &gt; 3 sqrt(var_v_hat) the filter is updated with 3
        sqrt(var_v_hat) rather than z(i). For instance v(i) will not be white
        in situations where packets are sent at a higher rate than the channel
        capacity, in which case they will be queued behind each other.</t>
      </section>

      <section title="Over-use detector">
        <t>The offset estimate m(i) is compared with a threshold gamma_1(i). 
        An estimate above the threshold is considered as an indication of
        over-use. Such an indication is not enough for the detector to signal
        over-use to the rate control subsystem. Not until over-use has been
        detected for at least gamma_2 milliseconds a definitive over-use will be signaled.
        However, if m(i) &lt; m(i-1), over-use will not be
        signaled even if all the above conditions are met. Similarly, the
        opposite state, under-use, is detected when m(i) &lt; -gamma_1(i). If
        neither over-use nor under-use is detected, the detector will be in
        the normal state.</t>
        <t>The threshold gamma_1 has a remarkable impact on the overall dynamics 
        and performance of the algorithm. 
        In particular, it has been shown that using a static threshold gamma_1,
        a flow controlled by the proposed algorithm can be starved by a
        concurrent TCP flow <xref target="Pv13"/>. This starvation can be 
        avoided by increasing the threshold gamma_1 to a sufficiently large 
        value.</t>
        <t>The reason is that, by using a larger value of gamma_1, a larger 
        queuing delay can be tolerated, whereas with a small gamma_1, the 
        over-use detector quickly reacts to a small increase in the offset estimate m(i)
        by generating an over-use signal that reduces A_r.
        Thus, it is necessary to dynamically tune the threshold gamma_1 to get good
        performance in the most common scenarios, such as when competing with 
        loss-based flows.</t>
        <t>For this reason, we propose to vary the threshold gamma_1(i) according
        to the following dynamic equation:</t>
         <figure>
           <artwork><![CDATA[
  gamma_1(i) = gamma_1(i-1) + (t(i)-t(i-1)) * K(i) * (|m(i)| - gamma_1(i-1))
]]></artwork>
         </figure>
        <t>with K(i)=k_d(i) if |m(i)| &lt; gamma_1(i-1) or K(i)=k_u(i) otherwise.
        The rationale is  to increase gamma_1(i) when m(i) is outside of the range
        [-gamma_1(i-1),gamma_1(i-1)], whereas, when the offset estimate m(i)
        falls back into the range, gamma_1 is decreased. In this way when
        m(i) increases, for instance due to a TCP flow entering the same
        bottleneck, gamma_1(i) increases and avoids the uncontrolled generation of
        over-use signals which may lead to starvation of the flow controlled by
        the proposed algorithm <xref target="Pv13"/>. Moreover, gamma_1(i) SHOULD NOT
        be updated if this condition holds:</t>
        <figure>
           <artwork><![CDATA[
  |m(i)| - gamma_1(i) > 15
]]></artwork>
         </figure>

        <t>On the other hand, when m(i) falls back into the range [-gamma_1(i-1),gamma_1(i-1)]
        the threshold gamma_1(i) is decreased so that a lower queuing delay can
        be achieved.</t>
        <t>It is RECOMMENDED to choose k_u(i) &gt; k_d(i) so that the rate at which gamma_1 is
        increased is higher than the rate at which it is decreased. Morever, to enforce
        intra-protocol fairness k_u(i) and k_d(i) are updated according to an average
        of the incoming bitrates at the receiver R_hat(i):</t>
                <figure>
           <artwork><![CDATA[
  k_u(i) = K_u + K_u * (R_max/2 - R_hat(i))/(R_max)
  k_d(i) = K_d + K_d * (R_hat(i) - R_max/2)/(R_max)
]]></artwork>
         </figure>

        <t>Where R_max is the maxmium allowed sending bitrate.
        With this setting it is possible to increase the threshold in the case of
        a concurrent TCP flow and prevent starvation as well as enforcing intra-protocol fairness.
        RECOMMENDED values for gamma_1(0), gamma_2, K_u and K_d are respectively 25 ms, 10 ms, 0.02 and 0.006.</t>
      </section>

      <section title="Rate control">
        <t>The rate control is split in two parts, one controlling the bandwidth
        estimate based on delay, and one controlling the bandwidth estimate based
        on loss. Both are designed to increase the estimate of the available 
        bandwidth A_hat as long as there is no detected congestion. Doing that
        ensures that we will eventually match the available bandwidth of the 
        channel and detect an over-use.</t>

        <t>As soon as over-use has been detected the receive-estimate of
        the available bandwidth is decreased. In this way we get a recursive
        and adaptive estimate of the available bandwidth.</t>

        <t>In this document we make the assumption that the rate control
        subsystem is executed periodically and that this period is
        constant.</t>

        <t>The rate control subsystem has 3 states: Increase, Decrease and
        Hold. "Increase" is the state when no congestion is detected;
        "Decrease" is the state where congestion is detected, and "Hold" is a
        state that waits until built-up queues have drained before going to
        "increase" state.</t>

        <t>The state transitions (with blank fields meaning "remain in state")
        are:</t>

        <t></t>

        <figure>
          <artwork><![CDATA[State ---->  | Hold      |Increase    |Decrease
Signal-----------------------------------------
  v          |           |            |
Over-use     | Decrease  |Decrease    |
-----------------------------------------------
Normal       | Increase  |            |Hold
-----------------------------------------------
Under-use    |           |Hold        |Hold
-----------------------------------------------



]]></artwork>
        </figure>

        <t>The subsystem starts in the increase state, where it will stay
        until over-use or under-use has been detected by the detector
        subsystem. On every update the delay-based estimate of the available
        bandwidth is increased, either multiplicatively or additively,
        depending on its current state.</t>

        <t>The system does a multiplicative
        increase if the current bandwidth estimate appears to be far from
        convergence, while it does an additive increase if it appears to
        be closer to convergence. We assume that we are close to convergence
        if the currently incoming bitrate, R_hat(i), is close to an average
        of the incoming bitrates at the time when we were in the Decrease
        state. "Close" is defined as three standard deviations around this
        average.</t>

        <t>R_hat(i) is the incoming bit rate measured by  the delay-based 
        controller over a T seconds
        window:</t>

        <figure>
          <artwork><![CDATA[
  R_hat(i) = 1/T * sum(L(j)) for j from 1 to N(i)]]></artwork>
        </figure>

        <t>N(i) is the number of packets received the past T seconds and L(j)
        is the payload size of packet j. A window between 0.5 and 1 second
        is RECOMMENDED.</t>

        <t>During multiplicative increase, the estimate is increased with 8%
        per second. </t> 

        <figure>
          <artwork><![CDATA[
  eta = 1.08^min(time_since_last_update, 1.0)
  A_hat(i) = eta * A_hat(i-1)]]>
          </artwork>
        </figure>

        <t>During the additive increase the estimate is increased with half an
        average packet per response interval. The response interval is estimated
        as the round-trip time plus 100 ms as an estimate of over-use estimator
        and detector reaction time.</t>

        <figure>
          <artwork><![CDATA[
  beta = 0.5 * min(time_since_last_update / response_time, 1.0)
  A_hat(i) = A_hat(i-1) + beta * avg_packet_size]]>
          </artwork>
        </figure>

        <t>Since the system depends on over-using the channel to verify the
        current available bandwidth estimate, we must make sure that our
        estimate does not diverge from the rate at which the sender is actually
        sending. Thus, if the sender is unable to produce a bit stream with
        the bit rate the congestion controller is asking for, the available
        bandwidth estimate should stay within a given bound. Therefore we
        introduce a threshold</t>

        <figure>
          <artwork><![CDATA[
  A_hat(i) < 1.5 * R_hat(i)
]]></artwork>
        </figure>

        <t>When an over-use is detected the system transitions to the decrease
        state, where the delay-based available bandwidth estimate is
        decreased to a factor times the currently incoming bit rate.</t>

        <figure>
          <artwork><![CDATA[
  A_hat(i) = alpha*R_hat(i)]]></artwork>
        </figure>

        <t>alpha is typically chosen to be in the interval [0.8, 0.95], 0.85
        is the RECOMMENDED value.</t>

        <t>When the detector signals under-use to the rate control subsystem,
        we know that queues in the network path are being emptied, indicating
        that our available bandwidth estimate is lower than the actual
        available bandwidth. Upon that signal the rate control subsystem will
        enter the hold state, where the receive-side available bandwidth
        estimate will be held constant while waiting for the queues to
        stabilize at a lower level &ndash; a way of keeping the delay as low
        as possible. This decrease of delay is wanted, and expected,
        immediately after the estimate has been reduced due to over-use, but
        can also happen if the cross traffic over some links is reduced.</t>
      </section>
    </section>

    <section anchor="lossbased" title="Loss-based control">
      <t>An second part of the congestion controller bases its decisions on the
      round-trip time, packet loss and available bandwidth estimates received
      from the delay-based controller.</t>

      <t>The available bandwidth estimates A_hat produced by the delay-based
      controller are only reliable when the size of the queues along the path
      sufficiently large enough. If the queues are very short, over-use will only be
      visible through packet losses, which are not used by the delay-based
      controller.</t>

      <t>The loss-based controller SHOULD run every time feedback from the
      receiver is received.</t>

      <t><list style="symbols">
          <t>If 2-10% of the packets have been lost since the previous report
          from the receiver, the sender available bandwidth estimate As_hat(i)
          (As_hat denotes &lsquo;sender available bandwidth&rsquo;) will be kept
          unchanged.</t>

          <t>If more than 10% of the packets have been lost a new estimate is
          calculated as As_hat(i)=As_hat(i-1)(1-0.5p), where p is the loss
          ratio.</t>

          <t>As long as less than 2% of the packets have been lost As_hat(i)
          will be increased as As_hat(i)=1.05(As_hat(i-1))</t>
        </list></t>

      <t>The new bandwidth estimate is limited by the TCP Friendly Rate
      Control formula <xref target="RFC3448"></xref> and the delay-based
      estimate of the available bandwidth A_hat(i):</t>

      <figure>
        <artwork><![CDATA[                               8 s
As_hat(i) >= ----------------------------------------------------------
         R*sqrt(2*b*p/3) + (t_RTO*(3*sqrt(3*b*p/8) * p * (1+32*p^2)))

As_hat(i) <= A_hat(i)

]]></artwork>
      </figure>

      <t>where b is the number of packets acknowledged by a single TCP
      acknowledgment (set to 1 per TFRC recommendations), t_RTO is the TCP
      retransmission timeout value in seconds (set to 4*R) and s is the
      average packet size in bytes. R is the round-trip time in seconds.</t>

      <t>(The multiplication by 8 comes because TFRC is computing bandwidth in
      bytes, while this document computes bandwidth in bits.)</t>

      <t>In words: The loss-based estimate will never be larger than the
      delay-based estimate, and will never be lower than the estimate from
      the TFRC formula.</t>

      <t>We motivate the packet loss thresholds by noting that if the
      transmission channel has a small amount of packet loss due to over-use,
      that amount will soon increase if the sender does not adjust his bit
      rate. Therefore we will soon enough reach above the 10% threshold and
      adjust As_hat(i). However, if the packet loss ratio does not increase, the
      losses are probably not related to self-inflicted congestion and
      therefore we should not react on them.</t>
    </section>

    <section title="Interoperability Considerations">
      <t>There are three scenarios of interest, and one included for
      reference</t>

      <t><list style="symbols">
          <t>Both parties implement the algorithms described here</t>

          <t>Sender implements the algorithm described in section <xref
          target="lossbased"></xref>, recipient does not implement <xref
          target="delaybased"></xref></t>

          <t>Recipient implements the algorithm in section <xref
          target="delaybased"></xref>, sender does not implement <xref
          target="lossbased"></xref>.</t>
        </list>In the case where both parties implement the algorithms, we
      expect to see most of the congestion control response to slowly varying
      conditions happen by REMB messages from recipient to sender. At
      most times, the sender will send less than the congestion-inducing
      bandwidth limit C, and when he sends more, congestion will be detected
      before packets are lost.</t>

      <t>If sudden changes happen, packets will be lost, and the sender side
      control will trigger, limiting traffic until the congestion becomes low
      enough that the system switches back to the receiver-controlled
      state.</t>

      <t>In the case where sender only implements this algorithm, we expect
      to see somewhat higher loss rates and delays, but the system will still
      be overall TCP friendly and self-adjusting; the governing term in the calculation will be the TFRC formula.</t>

      <t>In the case where the receiver implements this algorithm and sender does
      not, congestion will be avoided for slow changes as long as the sender
      understands and obeys REMB; there will be no backoff for
      packet-loss-inducing changes in capacity. Given that some kind of
      congestion control is mandatory for the sender according to the TMMBR
      spec, this case has to be reevaluated against the specific congestion
      control implemented by the sender.</t>
    </section>

    <section title="Implementation Experience">
      <t>This algorithm has been implemented in the open-source WebRTC
      project, and has been in use in Chrome since M23, and is being used by
      Google Hangouts.</t>
    </section>

    <section title="Further Work">
      <t>This draft is offered as input to the congestion control
      discussion.</t>

      <t>Work that can be done on this basis includes:</t>

      <t><list style="symbols">
          <t>Considerations of integrated loss control: How loss and delay
          control can be better integrated, and the loss control improved.</t>

          <t>Considerations of locus of control: Move the algorithm logic to
          the sender and evaluate the performance compared to splitting logic
          between sender and receiver.</t>

          <t>Considerations of over-bandwidth estimation: Whether we can use
          the estimate of how much we are over bandwidth in section 3 to
          influence how much we reduce the bandwidth, rather than using a
          fixed factor.</t>
        </list></t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document makes no request of IANA.</t>

      <t>Note to RFC Editor: this section may be removed on publication as an
      RFC.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>An attacker with the ability to insert or remove messages on the
      connection would have the ability to disrupt rate control.
      This could make the algorithm to produce either a sending rate 
      under-utilizing the bottleneck link capacity, or a too high sending rate  
      causing network congestion.</t>

      <t>In this case, the control information is carried inside RTP, and can
      be protected against modification or message insertion using SRTP, just
      as for the media. Given that timestamps are carried in the RTP header,
      which is not encrypted, this is not protected against disclosure, but it
      seems hard to mount an attack based on timing information only.</t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>Thanks to Randell Jesup, Magnus Westerlund, Varun Singh, Tim Panton,
      Soo-Hyun Choo, Jim Gettys, Ingemar Johansson, Michael Welzl and others
      for providing valuable feedback on earlier versions of this draft.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include='reference.RFC.3448'?>

      <?rfc include='reference.RFC.3550'?>

      <?rfc include='reference.RFC.5104'?>

      <?rfc include='reference.RFC.5450'?>

      <?rfc include='reference.I-D.alvestrand-rmcat-remb'?>

      <?rfc include='reference.I-D.holmer-rmcat-transport-wide-cc-extensions'?>

      <reference anchor="abs-send-time" target="http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time">
        <front>
          <title>RTP Header Extension for Absolute Sender Time</title>
          <author/>
          <date/>
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include='reference.I-D.gharai-avtcore-rtp-tfrc'?>

      <?rfc include='reference.RFC.2914'?>

      <reference anchor='Pv13'> 
        <front> 
          <title abbrev='Pv13'>Understanding the Dynamic Behaviour of the Google Congestion Control</title> 
          <author initials='L.' surname='De Cicco' fullname='Luca De Cicco'> 
            <organization>Politecnico di Bari</organization> 
            <address>
              <postal>
                <street>Via Orabona, 4</street>
                <street>70125 Bari</street>
                <street>Italy</street>
              </postal>
              <phone>+39 080 596 3851</phone>
              <email>l.decicco@poliba.it</email>
             </address> 
          </author> 
          <author initials='G.' surname='Carlucci' fullname='Gaetano Carlucci'> 
            <organization>Politecnico di Bari</organization>
            <address>
              <postal>
                <street>Via Orabona, 4</street>
                <street>70125 Bari</street>
                <street>Italy</street>
              </postal>
              <phone>+39 080 596 3851</phone>
              <email>g.carlucci@poliba.it</email>
             </address> 
          </author> 
          <author initials='S.' surname='Mascolo' fullname='Saverio Mascolo'>
            <organization>Politecnico di Bari</organization> 
            <address>
              <postal>
                <street>Via Orabona, 4</street>
                <street>70125 Bari</street>
                <street>Italy</street>
              </postal>
              <phone>+39 080 596 3621</phone>
              <email>mascolo@poliba.it</email>
             </address> 
          </author> 
          <date year='2013' month='December' />
          <area>General</area>
        </front> 
        <seriesInfo name="Packet Video Workshop" value="" />
        <format type="PDF" target="http://c3lab.poliba.it/images/c/ce/Gcc-pv-2013.pdf"/> 
      </reference> 

    </references>

    <section title="Change log">
      <t></t>

      <section title="Version -00 to -01">
        <t><list style="symbols">
            <t>Added change log</t>

            <t>Added appendix outlining new extensions</t>

            <t>Added a section on when to send feedback to the end of section
            3.3 "Rate control", and defined min/max FB intervals.</t>

            <t>Added size of over-bandwidth estimate usage to "further work"
            section.</t>

            <t>Added startup considerations to "further work" section.</t>

            <t>Added sender-delay considerations to "further work"
            section.</t>

            <t>Filled in acknowledgments section from mailing list
            discussion.</t>
          </list></t>
      </section>

      <section title="Version -01 to -02">
        <t><list style="symbols">
            <t>Defined the term "frame", incorporating the transmission time
            offset into its definition, and removed references to "video
            frame".</t>

            <t>Referred to "m(i)" from the text to make the derivation
            clearer.</t>

            <t>Made it clearer that we modify our estimates of available
            bandwidth, and not the true available bandwidth.</t>

            <t>Removed the appendixes outlining new extensions, added pointers
            to REMB draft and RFC 5450.</t>
          </list></t>
      </section>

      <section title="Version -02 to -03">
        <t><list style="symbols">
            <t>Added a section on how to process multiple streams in a single
            estimator using RTP timestamps to NTP time conversion.</t>

            <t>Stated in introduction that the draft is aimed at the RMCAT
            working group.</t>
          </list></t>
      </section>

      <section title="rtcweb-03 to rmcat-00">
        <t>Renamed draft to link the draft name to the RMCAT WG.</t>
      </section>

      <section title="rmcat -00 to -01">
        <t>Spellcheck. Otherwise no changes, this is a "keepalive"
        release.</t>

        <t></t>
      </section>

      <section title="rmcat -01 to -02">
        <t><list style="symbols">
            <t>Added Luca De Cicco and Saverio Mascolo as authors.</t>

            <t>Extended the "Over-use detector" section with new technical
             details on how to dynamically tune the offset gamma_1 for improved
             fairness properties.</t>

            <t>Added reference to a paper analyzing the behavior of the proposed
             algorithm.</t>
          </list></t>
      </section>
    </section>
  </back>
</rfc>

